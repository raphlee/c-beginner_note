1. Char is used for a character type. It is 16 bits, large enough for (nonsurrogate) Unicode characters.-> Char have 2 bytes
2. Strings Are Immutable (ko chỉnh sửa được)
3. One way to retrieve text that is entered at the console is to use System.Console.ReadLine()
4. The data type returned by the System.Console.Read() method is an integer corresponding to the character value read, or –1 if no more characters are available
5. The practice of placing a value directly into source code is called hardcoding, because changing the values requires recompiling the code. Developers must carefully consider the choice between hardcoding values within their code and retrieving them from an external source, such as a configuration file, so that the values are modifiable without recompiling.

6. The round-trip format specifier, R (or r).
	Ex: string.Format("{0:R}", 1.618033988749895)

7. In C#, you can use the @ symbol in front of a string to signify that a backslash should not be interpreted as the beginning of an escape sequence.
8. The using and using static Directives. The using static directive needs to appear at the top of the file.
9. One way to overcome the discrepancy between platforms is simply to use System.Console.WriteLine() to output a blank line. Another approach, which is almost essential for a new line on multiple platforms when you are not outputting to the console, is to use System.Environment.NewLine.
10. System.Text.StringBuilder (modifiable)

11. var indicates to the compiler that it should determine the data type from the value that is assigned within the declaration.

12. Value type data is always copied by value, while reference type data is always copied by reference.

13. A key factor when choosing between defining a reference type or a value type is whether the object is logically like an immutable value of fixed size (and therefore possibly a value type), or logically a mutable thing that can be referred to (and therefore likely to be a reference type).

14. To declare variables of value type that can store null, you use the 'nullable modifier', ?.

15. The syntax for a checked block uses the checked keyword.

16. Parse() | Another special type is available for converting one type to the next. This type is System.Convert

17. TryParse() method. This method is very similar to the Parse() method, except that instead of throwing an exception if the conversion fails, the TryParse() method returns false. -> By using TryParse() rather than Parse(), you can avoid throwing exceptions in expected situations.

18. Arrays include additional methods for manipulating the elements withinthe array—for example, Sort(), BinarySearch(), Reverse(), and Clear().
	-> Notice: System.Array.Clear(arr, firstIndex, secondIndex): This does not remove all items from the array, rather it sets each item to the type’s default value (from firstIndex to secondIndex of arr).

19. Clone array -> using Clone().

20. expression1 ?? expression2 -> If this value (expression1) is null, then use this other value (expression2).
	More example: x ?? y ?? z  :v

21. Null-Conditional Operator (?.) -> checking for null before invoking a member (prop / method)
	Example: args?.Length -> The null-conditional operator checks whether the operand (args is null prior to invoking the method or property (Length) =>>>>>>> Avoid using

22. foreach(type variable in collection) { statement }

23. Hints for Visual Editors (#region, #endregion). Callsapce ???

24. To support the simplest of method declarations without the formality of a method body, C# 6.0 introduced expression bodied methods, which are declared using an expression rather than a full method body
	"Goes to" operator: => 
	Ex: (static) string GetFullName(string firstName, string lastName) => $"{firstName} {lastName}";
	As such, their use should be limited to the simplest of method implementations—generally expressible on a single line.

25. Declaration and implementation appear together in the same file.

26. The using directive also allows aliasing a namespace or type -> to avoid code ambiguity
	Ex: using CountDownTimer = System.Timers.Timer;	// at the top of file

27. Reference Parameters (ref) - passed by reference. -> KEYWORD ref
	Ex: void swap(ref string a, ref string b){ string temp = a; a = b; b = temp; }. It'll swap original values of a and b.

28. A method that takes a reference to a variable intends to write to the variable, but not to read from it. In such cases, clearly it could be safe to pass an uninitialized local variable by reference. To achieve this, code needs to decorate parameter types with the keyword out.
	Ex: bool TryGetPhoneButton(char character, out char button){/*statement*/}

29. Parameter Arrays (params).
	Guide:
		1. Places params immediately before the LAST parameter in the method declaration
		2. Declares the LAST parameter

	Ex: void DoStuff(int a, params int[] listInteger) {/*statement*/}

30. Optional method
	Ex: void Method(int a; int b = 1);

31. Named Arguments.
	Ex:
		Main() method: Display("Sant", middleName : "Jur", lastName : "Lee");
				Display("Raph");
				Display("Leo", lastName : "Lee");

		Method: Display(string firstName, string middleName = default(string), string lastName = default(string)){}

32. Exception handling: In fact, it is possible to have a try block with a finally block and no catch block.
	Because all classes ultimately derive from object, a catch block with no data type must appear last.
	TRY - CATCH - FINALLY

33. Classes - THE GARBAGE COLLECTOR (JUST LIKE JAVA)
The garbage collector is responsible for the automatic de-allocation. It determines which objects are no longer referenced by other active objects and then de-allocates the memory for those objects.

34. this KEYWORD.

35. FileStream object and the FileMode (append, create, createNew, open, openOrCreate, Truncate). We have StreamWriter and StreamReader to write and read a file from FileStream, just like Java. 
	For ex:
		StreamWriter sw = new StreamWriter(new FileStream("myFile.file", FileMode.Create));
		sw.Close(); // must be closed

36.  Five access modifiers are available: public, private, protected, internal, and protected internal.
	By default, a class without any access modifier is defined as internal.

37. If no access modifier is placed on a class member, the declaration defaults to private. In other words, members are private by default and programmers need to specify explicitly that a member is to be public.

38. Recognizing the frequency of this type of pattern, the C# designers provided explicit syntax for it. This syntax is called a property: (I dunno if they have only set and get or not, but the example below will show set and get only)

	Example:
		private string _firstName;		// origin prop
		public string firstName			// property prop, origin prop' mask
		{
			get
			{
				return _firstName;	
			}

			set
			{
				_firstName = value; 	// value is special keyword for this scenario
			}
	
		}


39. Automatically Implemented Properties (shorthand - tốc ký)
With previous example, we also declare like this:
		public string firstName { get; set; }
	
	More ex: 
		public string lastName { get; set; } = "Raphael";  // init value (C# 6.0 and higher)

	// I'm confused. Example above, this is public access modifier.

40. The nameof operator takes an identifier, like the value variable, and returns a string representation of that name—in this case, "value".

41. Read-Only and Write-Only Properties
	public int value { get; }

42. Specifying an access modifier on the getter or setter
	Example: 

		private string _firstName;		// origin prop
		public string firstName			// property prop, origin prop' mask
		{
			get
			{
				return _firstName;	
			}

			private set			// access modifier, not on both
			{
				_firstName = value; 	// value is special keyword for this scenario
			}
	
		}

43. Properties and Method Calls Not Allowed As ref or out Parameter Values
44. Finalizer: To define what happens when an object is destroyed, C# provides the finalizer construct (///)
45. Constructor Chaining: Calling Another Constructor Using this
	Ex:
		public Me(string firstName, string lastName) {/*statement*/}
		public Me(string firstName, string lastName, int age) : this(firstName, lastName) {/*statement*/}

46. Unlike many of the languages that came before it, C# does not have global variables or global functions. All fields and methods in C# appear within the context of a class. The equivalent of a global field or function within the realm of C# is a static field or function. There is no functional difference between global variables/functions and C# static fields/methods, except that static fields/methods can include access modifiers, such as private, that can limit the access and provide better encapsulation.

Unlike with instance fields, if no initialization for a static field is provided, the static field will automatically be assigned its default value (0, null, false, and so on)—the equivalent of default(T), where T is the name of the type. As a result, it will be possible to access the static field even if it has never been explicitly assigned in the C# code.

Nonstatic fields, or instance fields, provide a new storage location for each object to which they belong. In contrast, static fields don’t belong to the instance, but rather to the class itself. As a result, you access a static field from outside a class via the class name.

'this' keyword is invalid inside a static method.

47. Static Constructor: no parameters are allowed on static constructors.

--
Just like property, we have static property as well.

48. Static Class
The static keyword on a class provides two facilities (điều kiện thuận lợi)
- First, it prevents a programmer from writing code that instantiates the static class. 
- Second, it prevents the declaration of any instance fields or methods within the class

49. const 
Constant fields are static automatically

50. readonly

51. Partial classes (lớp cục bộ): allow the splitting of a class definition across multiple files
	File1: ex1.cs
		partial class Program {}

	File2: ex2.cs
		partial class Program {}

52. Partial method: Any partial method must return void.
	Ex: partial void OnMethod(){}

53. Single Inheritance

54. Sealed classes include the sealed modifier, and the result is that they cannot be derived from

55. Virtual: The base class must mark each member for which it allows overriding as virtual. If public or protected members do not include the virtual modifier, subclasses will not be able to override those members.

Virtual methods should not include critical code because such methods may never be called if the derived class overrides them

56. 'new' and 'sealed' modifier for the inheritance method (be careful)

57. Just like 'super' in Java, C# have 'base' keyword to call directly base class.

58. Abtrast Class, can not be initialized (instance) | Polymorphism (đa hình): “Poly” means “many” and “morph” means “form,” so polymorphism refers to the fact that there are multiple implementations of the same signature.

59. In Java, all object refer to Object Class, so does C#. 
	C#:							All Classes Derive from System.Object
All object have System.Object's members like: Equals, GetHashCode, GetType, ToString, ...

60. 'is' operator to check type

61. 'as' operator. The as operator goes one step further: It attempts a conversion to a particular data type and assigns null if the source type is not inherently (within the inheritance chain) of the target type. This strategy is significant because it avoids the exception that could result from casting.

62. Interface: The base class specifier (if there is one) must come first, but otherwise order is not significant. Classes can implement multiple interfaces, but may derive directly from only one base class.


// Generic Classes

#head:		using System.Collection.Generic;

63. ArrayList
64. IComperable (like Comperator in Java, supported int CompareTo(Object o) function to compare, -1: less than, 0: equal, 1 greater.

65. IComparer: int Compare(Object o1, Object o2){}
66. Queue and Stack (see you)

67. Dictionary: HASHTABLE

68. Operator Overloading. 
	NOT SUPPORTED THESE OPERATOR: x.y, f(x), new, typeof, default, checked, unchecked, delegate, is, as, =, and =>

	BINARY OPERATOR: (+, -, *, /, %, &, |, ^, <<, >>)

	Combining Assignment with Binary Operators: (+=, -=, *=, /=, %=, &=, …)
	
	Conditional Logical Operators (&&, ||)

	Unary Operators (+, -, !, ~, ++, --, true, false)

69. NOTICE: Two variables never refer to the same storage location (unless one or both are 'out' or 'ref' parameters)

70. DO NOT create value types that consume more than 16 bytes of memory.

71. Reference types:
	A reference type variable, therefore, has two storage locations associated with it: the storage location directly associated with the variable, and the storage location referred to by the reference that is the value stored in the variable.

	This is why the guideline for value types is to ensure that they are never more than 16 bytes or thereabouts; if a value type is more than four times as expensive to copy as a reference, it probably should simply be a reference type.

72. Struct: readonly, automatically implemented properties

73. Enum values are actually implemented as nothing more than integer constants. By default, the first enum value is given the value 0, and each subsequent entry increases by 1. However, you can assign explicit values to enums.

	If you decide to use bit flag enums, the declaration of the enum should be marked with FlagsAttribute.
	Ex:
		[Flags]
    		public enum FileAttributes
    		{
        		ReadOnly =      1 << 0,     // 0000 0000 0000 0001
        		Hidden   =      1 << 1,     // 0000 0000 0000 0010

        		Moreover = ReadOnly | Hidden		//  Join Enum
    		}

	To join enum values, you use a bitwise OR operator. 					|
	To test for the existence of a particular bit you use the bitwise AND operator		&

74. Organize the complexity by breaking programs into multiple parts. 
To do this, developers move portions of a program into separate compiled units called class libraries or, simply, libraries. Programs then reference and rely on class libraries to provide parts of their functionality. The power of this concept is that two programs can rely on the same class library, thereby sharing the functionality of that class library across both programs and reducing the total amount of code needed.

75. Using namespace. Nested namespace

	Ex: 
	namespace Min {
		namespace World {
			// My class
		}
	}

	or
	
	namespace Min.World {
		// My class
	}

76. XML comments

77. Delegate (BE CAREFUL)

78. Lazy Initialization (Cool)

78. Extension Method

// Vietnamese infor source
Extension method giúp bạn tạo thêm các phương thức cho một lớp mà không cần thừa kế lại lớp đó. Với tính năng này, thậm chí khi đối tượng của bạn là null, bạn vẫn có thể thực hiện các phương thức extension của đối tượng đó một cách an toàn.

Các quy tắc khi định nghĩa và sử dụng extension method

–          Lớp chứa extension method phải là static

–          Extension method cũng phải là một phương  thức static

–          Tham số đầu tiên của extension method xác định kiểu của đối tượng được sử dụng (extension method sẽ thêm vào lớp của đối tượng đó) với từ khóa 'this'. Tham số này sẽ được bỏ qua khi bạn gọi extension method.

Một điểm cơ bản cần chú ý là khi sử dụng extension method: bởi vì chúng không thực sự nằm trong các lớp mà chúng được thêm vào, nên bạn cần chắc chắn rằng các extension method được khai báo để có thể truy xuất được tại nơi mà bạn cần sử dụng như modifier, namespace.

Example:

    public static class ExtensionForProgram
    {
        // all class and method you wanna add to A, must be static (public ?)
        // method must be had 'this' keyword to 1st param, this param must be A type.
        public static void DoProgramMe(this Program Integer)        // it must be a reference data type
        {
            Console.WriteLine("Extension");
        }
    }

    public class Program
    {
        static void Main(string[] args)
        {
            var lazyObject = new Lazy<object>(() => { return LoadData(); });
            Console.WriteLine(lazyObject);
            Console.WriteLine(lazyObject.Value);


            Program program = new Program();
            program.DoProgramMe();      // print Extension

            Console.ReadKey();
        }

        static string LoadData()
        {
            Console.WriteLine("Start loading");
            return "This is a 'HUGE' data";
        }
    }


79. Anonymous method
Anonymous method (tạm dịch là phương thức vô danh) là phương thức không có tên được khai báo với từ khóa 'delegate'. Anonymous method cho phép bạn tạo ra các hành động cho một cho delegate với cách viết inline.

Ex:

	    int[] IntArr = {1, 2, 3, 4, 5, 6, 7, 8, 9 };

            // from delegate ... -> Anonymous Method (Pridicate<T> match)
            int[] OddArr = Array.FindAll(IntArr, delegate (int value)
            {
                return value % 2 == 1;
            });



80. Delegate Func

Func cho phép khai báo và tạo ra các dạng delegate với số lượng tham số và kiểu trả về khác nhau, tương tự như khi bạn tạo ra một phương thức.

Func được dùng chủ yếu để tạo và lưu trữ một anonymous method ngắn gọn bằng lambda expression và được sử dụng như những phương thức thông thường.

Ex:
	// Mix with Lambda func
        // Syntax: Func<T, T, ..., TResult>


        // We can use it many times

                       // name of Func // parametter-list (Lambda func))
        Func<string, int> stringLength = s => s.Length; // here, T is string; TResult is type int

        // multiply float and int, and result is float
        Func<float, int, float> multiply = (x, y) => x * y;

        void DoThing()
        {
            Console.WriteLine(stringLength("Man of the world"));

            float result = multiply(1.3f, 22);
        } 