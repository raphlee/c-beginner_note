1. Char is used for a character type. It is 16 bits, large enough for (nonsurrogate) Unicode characters.-> Char have 2 bytes
2. Strings Are Immutable (ko chỉnh sửa được)
3. One way to retrieve text that is entered at the console is to use System.Console.ReadLine()
4. The data type returned by the System.Console.Read() method is an integer corresponding to the character value read, or –1 if no more characters are available
5. The practice of placing a value directly into source code is called hardcoding, because changing the values requires recompiling the code. Developers must carefully consider the choice between hardcoding values within their code and retrieving them from an external source, such as a configuration file, so that the values are modifiable without recompiling.

6. The round-trip format specifier, R (or r).
	Ex: string.Format("{0:R}", 1.618033988749895)

7. In C#, you can use the @ symbol in front of a string to signify that a backslash should not be interpreted as the beginning of an escape sequence.
8. The using and using static Directives. The using static directive needs to appear at the top of the file.
9. One way to overcome the discrepancy between platforms is simply to use System.Console.WriteLine() to output a blank line. Another approach, which is almost essential for a new line on multiple platforms when you are not outputting to the console, is to use System.Environment.NewLine.
10. System.Text.StringBuilder (modifiable)

11. var indicates to the compiler that it should determine the data type from the value that is assigned within the declaration.

12. Value type data is always copied by value, while reference type data is always copied by reference.

13. A key factor when choosing between defining a reference type or a value type is whether the object is logically like an immutable value of fixed size (and therefore possibly a value type), or logically a mutable thing that can be referred to (and therefore likely to be a reference type).

14. To declare variables of value type that can store null, you use the 'nullable modifier', ?.

15. The syntax for a checked block uses the checked keyword.

16. Parse() | Another special type is available for converting one type to the next. This type is System.Convert

17. TryParse() method. This method is very similar to the Parse() method, except that instead of throwing an exception if the conversion fails, the TryParse() method returns false. -> By using TryParse() rather than Parse(), you can avoid throwing exceptions in expected situations.

18. Arrays include additional methods for manipulating the elements withinthe array—for example, Sort(), BinarySearch(), Reverse(), and Clear().
	-> Notice: System.Array.Clear(arr, firstIndex, secondIndex): This does not remove all items from the array, rather it sets each item to the type’s default value (from firstIndex to secondIndex of arr).

19. Clone array -> using Clone().

20. expression1 ?? expression2 -> If this value (expression1) is null, then use this other value (expression2).
	More example: x ?? y ?? z  :v

21. Null-Conditional Operator (?.) -> checking for null before invoking a member (prop / method)
	Example: args?.Length -> The null-conditional operator checks whether the operand (args is null prior to invoking the method or property (Length) =>>>>>>> Avoid using

22. foreach(type variable in collection) { statement }

23. Hints for Visual Editors (#region, #endregion). Callsapce ???

24. To support the simplest of method declarations without the formality of a method body, C# 6.0 introduced expression bodied methods, which are declared using an expression rather than a full method body
	"Goes to" operator: => 
	Ex: (static) string GetFullName(string firstName, string lastName) => $"{firstName} {lastName}";
	As such, their use should be limited to the simplest of method implementations—generally expressible on a single line.

25. Declaration and implementation appear together in the same file.

26. The using directive also allows aliasing a namespace or type -> to avoid code ambiguity
	Ex: using CountDownTimer = System.Timers.Timer;	// at the top of file

27. Reference Parameters (ref) - passed by reference. -> KEYWORD ref
	Ex: void swap(ref string a, ref string b){ string temp = a; a = b; b = temp; }. It'll swap original values of a and b.

28. A method that takes a reference to a variable intends to write to the variable, but not to read from it. In such cases, clearly it could be safe to pass an uninitialized local variable by reference. To achieve this, code needs to decorate parameter types with the keyword out.
	Ex: bool TryGetPhoneButton(char character, out char button){/*statement*/}

29. Parameter Arrays (params).
	Guide:
		1. Places params immediately before the LAST parameter in the method declaration
		2. Declares the LAST parameter

	Ex: void DoStuff(int a, params int[] listInteger) {/*statement*/}

30. Optional method
	Ex: void Method(int a; int b = 1);

31. Named Arguments.
	Ex:
		Main() method: Display("Sant", middleName : "Jur", lastName : "Lee");
				Display("Raph");
				Display("Leo", lastName : "Lee");

		Method: Display(string firstName, string middleName = default(string), string lastName = default(string)){}

32. Exception handling: In fact, it is possible to have a try block with a finally block and no catch block.
	Because all classes ultimately derive from object, a catch block with no data type must appear last.
	TRY - CATCH - FINALLY

33. Classes - THE GARBAGE COLLECTOR (JUST LIKE JAVA)
The garbage collector is responsible for the automatic de-allocation. It determines which objects are no longer referenced by other active objects and then de-allocates the memory for those objects.

34. this KEYWORD.

35. FileStream object and the FileMode (append, create, createNew, open, openOrCreate, Truncate). We have StreamWriter and StreamReader to write and read a file from FileStream, just like Java. 
	For ex:
		StreamWriter sw = new StreamWriter(new FileStream("myFile.file", FileMode.Create));
		sw.Close(); // must be closed

36.  Five access modifiers are available: public, private, protected, internal, and protected internal

37. If no access modifier is placed on a class member, the declaration defaults to private. In other words, members are private by default and programmers need to specify explicitly that a member is to be public.

38. Recognizing the frequency of this type of pattern, the C# designers provided explicit syntax for it. This syntax is called a property: (I dunno if they have only set and get or not, but the example below will show set and get only)

	Example:
		private string _firstName;		// origin prop
		public string firstName			// property prop, origin prop' mask
		{
			get
			{
				return _firstName;	
			}

			set
			{
				_firstName = value; 	// value is special keyword for this scenario
			}
	
		}


39. Automatically Implemented Properties (shorthand - tốc ký)
With previous example, we also declare like this:
		public string firstName { get; set; }
	
	More ex: 
		public string lastName { get; set; } = "Raphael";  // init value (C# 6.0 and higher)

	// I'm confused. Example above, this is public access modifier.

40. The nameof operator takes an identifier, like the value variable, and returns a string representation of that name—in this case, "value".

41. Read-Only and Write-Only Properties
	public int value { get; }

42. Specifying an access modifier on the getter or setter
	Example: 

		private string _firstName;		// origin prop
		public string firstName			// property prop, origin prop' mask
		{
			get
			{
				return _firstName;	
			}

			private set			// access modifier, not on both
			{
				_firstName = value; 	// value is special keyword for this scenario
			}
	
		}

43. Properties and Method Calls Not Allowed As ref or out Parameter Values
44. Finalizer: To define what happens when an object is destroyed, C# provides the finalizer construct (///)
45. Constructor Chaining: Calling Another Constructor Using this
	Ex:
		public Me(string firstName, string lastName) {/*statement*/}
		public Me(string firstName, string lastName, int age) : this(firstName, lastName) {/*statement*/}

46. Unlike many of the languages that came before it, C# does not have global variables or global functions. All fields and methods in C# appear within the context of a class. The equivalent of a global field or function within the realm of C# is a static field or function. There is no functional difference between global variables/functions and C# static fields/methods, except that static fields/methods can include access modifiers, such as private, that can limit the access and provide better encapsulation.

Unlike with instance fields, if no initialization for a static field is provided, the static field will automatically be assigned its default value (0, null, false, and so on)—the equivalent of default(T), where T is the name of the type. As a result, it will be possible to access the static field even if it has never been explicitly assigned in the C# code.

Nonstatic fields, or instance fields, provide a new storage location for each object to which they belong. In contrast, static fields don’t belong to the instance, but rather to the class itself. As a result, you access a static field from outside a class via the class name.

'this' keyword is invalid inside a static method.

47. Static Constructor: no parameters are allowed on static constructors.

--
Just like property, we have static property as well.

48. Static Class
The static keyword on a class provides two facilities (điều kiện thuận lợi)
- First, it prevents a programmer from writing code that instantiates the static class. 
- Second, it prevents the declaration of any instance fields or methods within the class

49. const 
Constant fields are static automatically

50. readonly

51. Partial classes (lớp cục bộ): allow the splitting of a class definition across multiple files
	File1: ex1.cs
		partial class Program {}

	File2: ex2.cs
		partial class Program {}

52. Partial method: Any partial method must return void.
	Ex: partial void OnMethod(){}

53. Single Inheritance

54. Sealed classes include the sealed modifier, and the result is that they cannot be derived from

55. Virtual: The base class must mark each member for which it allows overriding as virtual. If public or protected members do not include the virtual modifier, subclasses will not be able to override those members.

Virtual methods should not include critical code because such methods may never be called if the derived class overrides them

56. 'new' and 'sealed' modifier for the inheritance method (be careful)

57. Just like 'super' in Java, C# have 'base' keyword to call directly base class.

58. Abtrast Class, can not be initialized (instance) | Polymorphism (đa hình): “Poly” means “many” and “morph” means “form,” so polymorphism refers to the fact that there are multiple implementations of the same signature.

59. In Java, all object refer to Object Class, so does C#. 
	C#:							All Classes Derive from System.Object
All object have System.Object's members like: Equals, GetHashCode, GetType, ToString, ...

60. 'is' operator to check type

61. 'as' operator. The as operator goes one step further: It attempts a conversion to a particular data type and assigns null if the source type is not inherently (within the inheritance chain) of the target type. This strategy is significant because it avoids the exception that could result from casting.

62. Interface: The base class specifier (if there is one) must come first, but otherwise order is not significant. Classes can implement multiple interfaces, but may derive directly from only one base class.


// Generic Classes
63. ArrayList
64. IComperable (like Comperator in Java, supported int CompareTo(Object o) function to compare, -1: less than, 0: equal, 1 greater.

65. IComparer: int Compare(Object o1, Object o2){}
66. Queue and Stack (see you)

67. Dictionary: HASHTABLE